Index: Makefile
===================================================================
--- Makefile	(revision 57710)
+++ Makefile	(working copy)
@@ -129,6 +129,7 @@
 EXTRA_CFLAGS += -DONEBOX_CONFIG_WOWLAN
 #EXTRA_CFLAGS += -DONEBOX_CONFIG_GTK_OFFLOAD
 #EXTRA_CFLAGS += -DONEBOX_CONFIG_PUF
+EXTRA_CFLAGS += -D DYNAMIC_ROAMING
 EXTRA_CFLAGS += -I$(ROOT_DIR)/$(IEEE80211_DIR)/osd_linux/include/
 EXTRA_CFLAGS += -I$(ROOT_DIR)/$(IEEE80211_DIR)/osi_net80211/net80211/
 EXTRA_CFLAGS += -I$(ROOT_DIR)/$(IEEE80211_DIR)/osi_net80211/
Index: wlan/net80211/linux/osd_linux/include/cfg80211_ioctl.h
===================================================================
--- wlan/net80211/linux/osd_linux/include/cfg80211_ioctl.h	(revision 57710)
+++ wlan/net80211/linux/osd_linux/include/cfg80211_ioctl.h	(working copy)
@@ -132,6 +132,7 @@
 	int	len;		/* data size in bytes */
 	int8_t		se_rssi;	/* avg'd recv ssi */
 	int8_t		se_noise;	/* noise floor */
+	uint64_t 	tsf;            /* TSF of last recevied Beacon */
 };
 
 struct local_info {
@@ -356,6 +357,35 @@
 		u8 key_len, key_idx;
 } cfg80211_auth_req;
 
+#ifdef RSI_CCX
+#define CCKM_REASOC_REQ_IE        0x9c  //CCKM reassociation request element
+/*
+   CCKM reassociation request element
+   +-----------+-------+----------+----------+-----------+----------------+--------------+
+   |Element ID |Length | OUI      | OUI Type | Timestamp | RN             | MIC MN       |
+   +-----------+-------+----------+----------+-----------+----------------+--------------+
+   |1byte      |1 Byte | 3bytes   |  1byte   | 8bytes    | 4bytes         | 8bytes       |
+   +-----------+-------+----------+----------+-----------+----------------+--------------+
+   |0x9c       |24     | 00:46:96 |   0      | TSF timer | Next rekey     |              |
+   +-----------+-------+----------+----------+-----------+----------------+--------------+
+*/
+struct cckm_reassoc_ie {
+	u8 EID;
+	u8 length;
+	u8 OUI[3];
+	u8 OUI_type;
+	u64 time_stamp;
+	u32 RN;
+	u64 MIC;	
+}__attribute__((packed));
+
+enum onebox_vendor_sub_events {
+	BGSCAN_COMPLETED_EVENT, // Note this should always start from zero
+	ONEBOX_MAX_VENDOR_EVENT = ( BGSCAN_COMPLETED_EVENT + 1), // Keep this Last
+
+};
+#endif /* RSI_CCX */
+
 int obm_notify_ft_event (struct wireless_dev *wdev, const uint8_t *ies, size_t ies_len, uint8_t *mac);
 int obm_update_ft_ies(struct net_device *ndev, cfg80211_ft_params *ftie);
 int obm_send_auth(struct net_device *ndev, cfg80211_auth_req *req);
@@ -375,3 +405,9 @@
         const u8 *resp_ie, size_t resp_ie_len, const u8 *ssid, size_t ssid_len, gfp_t gfp) ;
 #endif
 
+int cfg80211_send_vendor_event_to_upper_layer (struct wireless_dev *wdev, const u8 *data, 
+							int length, int vendor_event_id, gfp_t gfp) ;
+
+int onebox_send_vendor_event_to_upper_layer (struct wireless_dev *wdev, const u8* data,int length, int vendor_event_id, gfp_t gfp) ;
+
+
Index: wlan/net80211/linux/osd_linux/include/cfg80211_wrapper.h
===================================================================
--- wlan/net80211/linux/osd_linux/include/cfg80211_wrapper.h	(revision 57710)
+++ wlan/net80211/linux/osd_linux/include/cfg80211_wrapper.h	(working copy)
@@ -307,6 +307,81 @@
 //#endif
 };
 
+#define REDPINE_OUI	0x0023a7
+int onebox_handle_vendor_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,
+		const void *data, int data_len);
+
+
+int onebox_send_vendor_event_to_upper_layer (struct wireless_dev *wdev, const u8* data,int length, int vendor_event_id, gfp_t gfp) ;
+
+
+/**
+ * struct nl80211_vendor_cmd_info - vendor command data
+ * @vendor_id: If the %NL80211_VENDOR_ID_IS_LINUX flag is clear, then the
+ *	value is a 24-bit OUI; if it is set then a separately allocated ID
+ *	may be used, but no such IDs are allocated yet. New IDs should be
+ *	added to this file when needed.
+ * @subcmd: sub-command ID for the command
+ *
+struct nl80211_vendor_cmd_info {
+	__u32 vendor_id;
+	__u32 subcmd;
+};
+*/
+
+/**
+ * struct wiphy_vendor_command - vendor command definition
+ * @info: vendor command identifying information, as used in nl80211
+ * @flags: flags, see &enum wiphy_vendor_command_flags
+ * @doit: callback for the operation, note that wdev is %NULL if the
+ *	flags didn't ask for a wdev and non-%NULL otherwise; the data
+ *	pointer may be %NULL if userspace provided no data at all
+ * @dumpit: dump callback, for transferring bigger/multiple items. The
+ *	@storage points to cb->args[5], ie. is preserved over the multiple
+ *	dumpit calls.
+ * It's recommended to not have the same sub command with both @doit and
+ * @dumpit, so that userspace can assume certain ones are get and others
+ * are used with dump requests.
+struct wiphy_vendor_command {
+	struct nl80211_vendor_cmd_info info;
+	u32 flags;
+	int (*doit)(struct wiphy *wiphy, struct wireless_dev *wdev,
+		    const void *data, int data_len);
+	int (*dumpit)(struct wiphy *wiphy, struct wireless_dev *wdev,
+		      struct sk_buff *skb, const void *data, int data_len,
+		      unsigned long *storage);
+};
+*/
+enum onebox_vendor_subcmd {
+	ONEBOX_CCX_GET_BEACON_IE = 1,
+	ONEBOX_MAX_VENDOR_CMD = ONEBOX_CCX_GET_BEACON_IE,
+};
+
+struct wiphy_vendor_command  onebox_vendor_cmd [] = {
+	{
+		.info = { 
+			.vendor_id = REDPINE_OUI,
+			.subcmd   = ONEBOX_CCX_GET_BEACON_IE,
+		},
+			.flags  = 0, /*If this flag is unset, the lower 24 bits are an OUI */
+			.doit = onebox_handle_vendor_cmd,
+	},
+};
+#if 0
+enum onebox_vendor_sub_events {
+	BGSCAN_COMPLETED_EVENT, // Note this should always start from zero
+	ONEBOX_MAX_VENDOR_EVENT = ( BGSCAN_COMPLETED_EVENT + 1), // Keep this Last
+
+};
+#endif
+struct nl80211_vendor_cmd_info onebox_vendor_event [] = {
+	{ 
+		.vendor_id = REDPINE_OUI,
+		.subcmd = BGSCAN_COMPLETED_EVENT,
+	},
+};
+
+
 /* Function prototypes */
 //uint8_t cfg80211_wrapper_attach(struct net_device *dev, void *dev_ptr, int size);
 struct cfg80211_priv* cfg80211_wrapper_attach(struct device *dev, u8 *mac_addr , struct ieee80211com *ic, u8 dual_band);
Index: wlan/net80211/linux/osd_linux/src/cfg80211_ioctl.c
===================================================================
--- wlan/net80211/linux/osd_linux/src/cfg80211_ioctl.c	(revision 57710)
+++ wlan/net80211/linux/osd_linux/src/cfg80211_ioctl.c	(working copy)
@@ -312,6 +312,9 @@
 #if(LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32))
 	cfg_events->cfg80211_notify_roaming = onebox_notify_cfg80211_roamed;
 #endif /* LINUX_VERSION_CODE */
+
+	cfg_events->cfg80211_send_vendor_event_to_upper_layer = onebox_send_vendor_event_to_upper_layer ;
+
 }
 
 int
@@ -560,7 +563,7 @@
 	struct ieee80211_scan_h *hscan;
 	int ret = ONEBOX_STATUS_SUCCESS;
 
-	hscan = kmalloc(sizeof(struct ieee80211_scan_h), GFP_KERNEL);
+	hscan = kzalloc(sizeof(struct ieee80211_scan_h), GFP_KERNEL);
 	memcpy(hscan->se_bssid, ise->se_bssid, IEEE80211_ADDR_LEN);
 	memcpy(hscan->se_ssid, ise->se_ssid, IEEE80211_NWID_LEN);
 	hscan->se_intval = ise->se_intval;
@@ -571,6 +574,7 @@
 	hscan->len = ise->se_ies.len;
 	hscan->se_rssi = ise->se_rssi;
 	hscan->se_noise = ise->se_noise;
+	hscan->tsf      =  ise->se_tstamp.tsf;
 
 	if (scan_results_sup(&vap->wdev,hscan) < 0)
 		ret = ONEBOX_STATUS_FAILURE;
@@ -651,11 +655,13 @@
 {
 	struct ieee80211vap *vap;
 	struct ieee80211req_mlme mlme;
+#ifdef RSI_CCX
+	struct cckm_reassoc_ie *ccx_ie = NULL;
+#endif /* RSI_CCX */
 	int authmode;
 	vap = netdev_priv(ndev);
-	
 	if(onebox_set_mediaopt(ndev, IFM_OMASK, 0) < 0)
-	{
+		{
 		IEEE80211_DBG_PRINT(vap, IEEE80211_MSG_ASSOC, ("Failed to set Operation mode %s Line %d\n", __func__, __LINE__));
 	//	return -1;
 	}
@@ -689,16 +695,29 @@
 		IEEE80211_DBG_PRINT(vap, IEEE80211_MSG_ERROR, ("WPA Ioctl Not set\n"));
 		return -1;
 	}
-
+	
 	if(((connect_params->ssid != NULL) && onebox_prepare_ioctl_cmd(vap, IEEE80211_IOC_SSID, connect_params->ssid, 0, connect_params->ssid_len)) < 0)
 	{
 		IEEE80211_DBG_PRINT(vap, IEEE80211_MSG_ERROR, ("SSID Ioctl Not set\n"));
 		return -1;
 	}
-    vap->channel = connect_params->channel;
+	vap->channel = connect_params->channel;
 	
 	memset(&mlme, 0, sizeof(mlme));
 	mlme.im_op = IEEE80211_MLME_ASSOC;
+#ifdef RSI_CCX
+	if(connect_params->ie && connect_params->ie_len 
+			&& (connect_params->ie_len > connect_params->ie[1])) {
+
+		if(connect_params->ie[connect_params->ie[1] + 2] == CCKM_REASOC_REQ_IE) {
+			ccx_ie = (struct cckm_reassoc_ie *)(connect_params->ie + connect_params->ie[1] + 2);
+			mlme.ccx_capable = 1;
+			mlme.tsf = ccx_ie->time_stamp;
+			mlme.rn = ccx_ie->RN;
+			mlme.mic = ccx_ie->MIC; 
+		}	
+	}
+#endif /* RSI_CCX */
 	if(connect_params->ssid != NULL)
 	{
 		memcpy(mlme.im_ssid, connect_params->ssid, connect_params->ssid_len);
Index: wlan/net80211/linux/osd_linux/src/cfg80211_wrapper.c
===================================================================
--- wlan/net80211/linux/osd_linux/src/cfg80211_wrapper.c	(revision 57710)
+++ wlan/net80211/linux/osd_linux/src/cfg80211_wrapper.c	(working copy)
@@ -34,6 +34,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/version.h>
 #include <linux/hardirq.h>
+#include <linux/kernel.h>
 #include "linux/wireless.h"
 #include "cfg80211_wrapper.h"
 #include "cfg80211_ioctl.h"
@@ -204,7 +205,7 @@
                                                    params->bssid[2],					
                                                    params->bssid[3],					
                                                    params->bssid[4],					
-                                                   params->bssid[5]));
+						   params->bssid[5]));
 	if(params->key)
         {
          	if(onebox_wep_key(ndev, params->key_idx, params->bssid, params->key_len, params->key) < 0)
@@ -440,7 +441,7 @@
 
 	struct ieee80211_mgmt *mgmt = NULL;
 	struct cfg80211_bss *bss = NULL;
-	char *temp;
+	uint8_t *temp;
 	BEACON_PROBE_FORMAT *frame;
 	int frame_len = 0;
 	uint8_t band;
@@ -455,6 +456,7 @@
 	temp = (unsigned char *)&frame->timestamp[0];
 
 	memset(temp, 0, 8);
+	memcpy(&frame->timestamp,(uint8_t*)&hscan->tsf, 8);
 	frame->beacon_intvl = cpu_to_le16(hscan->se_intval);
 	frame->capability   = cpu_to_le16(hscan->se_capinfo);
 	temp = frame->variable;
@@ -471,6 +473,7 @@
 		hscan->len -= 2;
 		hscan->data += 2 ;
 	}
+
 	nl80211_memcpy(temp, hscan->data, hscan->len );
 	frame_len += offsetof(struct ieee80211_mgmt, u.beacon.variable);
 	frame_len += hscan->len;
@@ -509,10 +512,14 @@
 		signal_level = abs(216 - ((SIGNAL_LEVEL*hscan->se_rssi)/10)) ;
 	}
 #endif
+	ONEBOX_DEBUG(ONEBOX_ZONE_INFO,("%s SSID =[%s] Mac =[%02x:%02x:%02x:%02x:%02x:%02x]  Signal[%d]dBm\n",
+					__func__,(char*)(&hscan->se_ssid[2]),hscan->se_bssid[0],hscan->se_bssid[1],
+					hscan->se_bssid[2],hscan->se_bssid[3],hscan->se_bssid[4],hscan->se_bssid[5],
+					hscan->se_rssi));
 	signal_level = -hscan->se_rssi;
-
+	
 	bss = cfg80211_inform_bss_frame(wiphy, channel, mgmt,
-				cpu_to_le16(frame_len), signal_level * 100,
+				cpu_to_le16(frame_len), (signal_level * 100),
 				GFP_ATOMIC);
 	if (!bss) {
 		kfree(mgmt);
@@ -594,17 +601,11 @@
 	return memcpy(to,from,len);
 }
 
-#if !defined(CONFIG_11R ) || ((LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)))
-void notify_sta_connect_to_cfg80211(struct wireless_dev *wdev, uint8_t mac[6])
-{
-	cfg80211_connect_result(wdev->netdev, mac, NULL, 0, NULL, 0, 0, GFP_ATOMIC);
-}
-#else
 void notify_sta_connect_to_cfg80211(struct wireless_dev *wdev, uint8_t mac[6], uint8_t *resp_ie, size_t resp_ie_len)
 {
 	cfg80211_connect_result(wdev->netdev, mac, NULL, 0, resp_ie, resp_ie_len, 0, GFP_ATOMIC);
+
 }
-#endif //CONFIG_11R
 
 void notify_sta_disconnect_to_cfg80211(struct wireless_dev *wdev)
 {
@@ -1945,6 +1946,21 @@
 	return 0;
 }
 
+int onebox_handle_vendor_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,
+		const void *data, int data_len) {
+	ONEBOX_DEBUG(ONEBOX_ZONE_ERROR,("%s  \n",__func__));
+	return 0;
+}
+
+int onebox_register_vendor_cmd(struct wiphy *wiphy)
+{
+	wiphy->vendor_commands = onebox_vendor_cmd;
+	wiphy->n_vendor_commands = ARRAY_SIZE(onebox_vendor_cmd);
+	wiphy->vendor_events = onebox_vendor_event;
+	wiphy->n_vendor_events = ARRAY_SIZE(onebox_vendor_event); 
+	return 0;	
+};
+
 /*
  * This function registers the device with CFG802.11 subsystem.
  *
@@ -2067,6 +2083,8 @@
 #endif
 #endif	
 
+	onebox_register_vendor_cmd(wiphy);
+
 	ret = wiphy_register(wiphy);
 	if (ret < 0) {
 		dev_err(dev,
@@ -2174,5 +2192,35 @@
     cfg80211_roamed(dev, bssid, req_ie, req_ie_len, resp_ie, resp_ie_len, GFP_KERNEL);
 #endif
 }
+
+int onebox_send_vendor_event_to_upper_layer (struct wireless_dev *wdev, const u8 *data,int length, int vendor_event_id, gfp_t gfp) 
+{
+
+	struct wiphy *wiphy = wdev->wiphy;	
+	struct sk_buff *skb = NULL;
+
+#if(LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 1))
+	skb = cfg80211_vendor_event_alloc(wiphy, wdev, length, vendor_event_id, gfp);
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, length, vendor_event_id, gfp);
+#endif /* LINUX_VERSION_CODE */
+	
+	if(skb == NULL)
+	{
+		ONEBOX_DEBUG(ONEBOX_ZONE_ERROR,("%s: failed .. \n",__func__));		
+		return -ENOMEM;
+	}
+
+	if( (data != NULL) && (length > 0)) {
+		if(nla_append(skb, length, data) < 0 ) {
+			ONEBOX_DEBUG(ONEBOX_ZONE_ERROR,("%s: failed .. \n",__func__));		
+			return -EINVAL;
+		}
+	}
+	/* This function sends the given @skb, which must have been allocated
+	 * by cfg80211_vendor_event_alloc(), as an event. It always consumes it. */
+	cfg80211_vendor_event(skb, gfp);  /* No need to free skb It always consumes it */
+	return 0;
+}
 #endif
 #endif
Index: wlan/net80211/linux/osi_net80211/net80211/ieee80211.h
===================================================================
--- wlan/net80211/linux/osi_net80211/net80211/ieee80211.h	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/net80211/ieee80211.h	(working copy)
@@ -295,7 +295,7 @@
 	uint8_t		ccx_id;		/* IEEE80211_ELEMID_VENDOR */
 	uint8_t		ccx_len;	/* length in bytes */
 	uint8_t		ccx_oui[3];	/* 0x00, 0x40,0x96  */
-	uint8_t		version;	/* version */
+	uint8_t		version;	/* IE type is version(0x3) */
 	uint8_t		ccx_version;	/* ccx version */
 } __packed;
 
@@ -315,7 +315,7 @@
  * Aironet Cisco Properietary element IE
  */
 struct ieee80211_aironet_ie {
-	uint8_t		airo_id; 		 /*IEEE80211_ELEMID_AIRONET 0x85 */
+	uint8_t		airo_id; 		 /*IEEE80211_ELEMID_AIRONET 0x85 Cisco CCX1 CKIP+Device Name */
 	uint8_t		airo_len;    		 /*length in bytes */ 
 	uint8_t		airo_oui[3];	 	 /* 0x00, 0x00, 0x66 */
 	uint8_t		airo_value[7];	 
@@ -913,15 +913,15 @@
 #ifdef CONFIG_11W
 	IEEE80211_ELEMID_MMIE		= 76,
 #endif
-	IEEE80211_ELEMID_TPC		= 150,
+	IEEE80211_ELEMID_TPC		= 150, /* AP Transmit Power */
 #ifdef RSI_CCX
 	IEEE80211_ELEMID_DDP		= 155, /*0x9b : Adjacent AP report*/
-	IEEE80211_ELEMID_AIRONET	= 133,
-	IEEE80211_ELEMID_AIRONET_RSD	= 0x96,
-	IEEE80211_ELEMID_AIRONET_IP	= 0x95,
+	IEEE80211_ELEMID_AIRONET	= 133, /* (0x85) Cisco CCX1 CKIP + Device Name*/
+	IEEE80211_ELEMID_AIRONET_RSD	= 0x96, /* Cell Power Information Element Id*/
+	IEEE80211_ELEMID_AIRONET_IP	= 0x95, /* AP IP address information element */
 #endif
-	IEEE80211_ELEMID_CCKM		= 156,
-	IEEE80211_ELEMID_VENDOR		= 221,	/* vendor private */
+	IEEE80211_ELEMID_CCKM		= 156,  /* (0x9c) CCKM reassociation request element */
+	IEEE80211_ELEMID_VENDOR		= 221,	/* vendor private  */
 
 	/*
 	 * 802.11s IEs
Index: wlan/net80211/linux/osi_net80211/net80211/ieee80211_node.h
===================================================================
--- wlan/net80211/linux/osi_net80211/net80211/ieee80211_node.h	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/net80211/ieee80211_node.h	(working copy)
@@ -100,6 +100,7 @@
 	uint8_t *aironet_ie;         	/*Cisco ie */
 	uint8_t *aironet_rsd_ie;      
 	uint8_t *aironet_client_pwr_ie; /*Cisco client TX power limiting ie */
+	uint8_t *reassoc_resp_cckm_ie;
 #endif 
 	uint8_t *pwr_cnstraint_ie;
 	uint8_t *country_ie;
Index: wlan/net80211/linux/osi_net80211/net80211/ieee80211_scan.h
===================================================================
--- wlan/net80211/linux/osi_net80211/net80211/ieee80211_scan.h	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/net80211/ieee80211_scan.h	(working copy)
@@ -222,6 +222,7 @@
 #ifdef RSI_CCX
 	uint8_t 	*aironet_ie;
 	uint8_t 	*aironet_client_pwr_ie;
+	uint8_t 	*aironet_version_ie;
 	uint8_t 	ccx_capable;
 #endif
 #if defined(CONFIG_11R ) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)))
Index: wlan/net80211/linux/osi_net80211/net80211/ieee80211_var.h
===================================================================
--- wlan/net80211/linux/osi_net80211/net80211/ieee80211_var.h	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/net80211/ieee80211_var.h	(working copy)
@@ -192,6 +192,8 @@
         const u8 *req_ie, size_t req_ie_len,
         const u8 *resp_ie, size_t resp_ie_len, const u8 *ssid, size_t ssid_len, gfp_t gfp) ;
 #endif /* LINUX_VERSION */
+int (*cfg80211_send_vendor_event_to_upper_layer) (struct wireless_dev *wdev, const u8 *data, 
+							int length, int vendor_event_id, gfp_t gfp) ;
 };
 #endif
 struct ieee80211_channel_rsi *addchan_based_cie(struct ieee80211com *ic, int ieee, int flags);
Index: wlan/net80211/linux/osi_net80211/src/ieee80211_input.c
===================================================================
--- wlan/net80211/linux/osi_net80211/src/ieee80211_input.c	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/src/ieee80211_input.c	(working copy)
@@ -747,6 +747,7 @@
 #ifdef RSI_CCX
 			if(isccxoui(frm)) {
 				scan->ccx_capable = 1;
+				scan->aironet_version_ie = frm;	
 			}
 #endif
 			break;
Index: wlan/net80211/linux/osi_net80211/src/ieee80211_linux.c
===================================================================
--- wlan/net80211/linux/osi_net80211/src/ieee80211_linux.c	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/src/ieee80211_linux.c	(working copy)
@@ -240,6 +240,35 @@
 		} else {
 			vap->iv_ic->cfg80211_call_backs.cfg_sta_connection_confirm(&vap->wdev, ni->ni_macaddr,data,length);
 		}
+#elif defined(RSI_CCX ) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)))
+		if(vap->hal_priv_vap->reassoc_ind & REASSOCIATED) {
+			IEEE80211_DBG_PRINT(vap,IEEE80211_MSG_ERROR,("%s: notify roamed [%02x:%02x:%02x:%02x:%02x:%02x]\n",__func__,ni->ni_macaddr[0],
+						ni->ni_macaddr[1],ni->ni_macaddr[2],ni->ni_macaddr[2],ni->ni_macaddr[4],ni->ni_macaddr[5] ));
+
+						ni_ies = &ni->ni_ies;
+						memset(data, 0,512);
+						if(ni_ies->wpa_ie) {
+							nl80211_memcpy(data, ni_ies->wpa_ie, ni_ies->wpa_ie[1]+2);
+							length = data[1]+2;
+							IEEE80211_DBG_PRINT(vap,IEEE80211_MSG_ELEMID,("%s:%d WPA_IE added \n",__func__,__LINE__));
+						}
+						if(ni_ies->reassoc_resp_cckm_ie) {
+							nl80211_memcpy(data+length, ni_ies->reassoc_resp_cckm_ie, ni_ies->reassoc_resp_cckm_ie[1]+2);
+							length = length + ni_ies->reassoc_resp_cckm_ie[1]+2;
+							IEEE80211_DBG_PRINT(vap,IEEE80211_MSG_ASSOC,("%s:%d REASSOC RESP CCKM_IE added \n",__func__,__LINE__));
+						}
+			vap->iv_ic->cfg80211_call_backs.cfg80211_notify_roaming(vap->iv_ifp, vap->channel, ni->ni_macaddr,
+					vap->iv_appie_wpa ? vap->iv_appie_wpa->ie_data : NULL, vap->iv_appie_wpa ? vap->iv_appie_wpa->ie_len : 0, //assoc_req ie & len
+					data, length,	// resp ie and length
+					vap->iv_des_ssid[0].ssid,	//SSID and length 
+					vap->iv_des_ssid[0].len, GFP_KERNEL); 
+			if(ni->ni_ies.wpa_ie != NULL && ni->ni_ies.reassoc_resp_cckm_ie!= NULL) {
+				vap->hal_priv_vap->eapol4_confrm = true;
+				IEEE80211_DBG_PRINT(vap,IEEE80211_MSG_ASSOC,("%s: Mark 4-way is completed  \n",__func__));
+			}
+		} else {
+			vap->iv_ic->cfg80211_call_backs.cfg_sta_connection_confirm(&vap->wdev, ni->ni_macaddr,data,length);
+		}
 #else
 		if(vap->hal_priv_vap->reassoc_ind & REASSOCIATED) {
 #if(LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32))
@@ -249,7 +278,7 @@
 					vap->iv_des_ssid[0].ssid, vap->iv_des_ssid[0].len, GFP_KERNEL);
 		} else {
 #endif
-			vap->iv_ic->cfg80211_call_backs.cfg_sta_connection_confirm(&vap->wdev, ni->ni_macaddr);
+			vap->iv_ic->cfg80211_call_backs.cfg_sta_connection_confirm(&vap->wdev, ni->ni_macaddr, NULL, 0);
 		}
 #endif
 		vap->hal_priv_vap->reassoc_ind &= ~(REASSOCIATED | REASSOCIATION_RECVD | REASSOCIATION_TIMEOUT);
@@ -398,6 +427,11 @@
 		vap->iv_ic->cfg80211_call_backs.cfg80211_scan_done(vap->scan_request,scan_failed);
 		vap->scan_request = NULL;
 	}
+#if (defined (DYNAMIC_ROAMING) || defined (RSI_CCX))
+	else {
+		vap->iv_ic->cfg80211_call_backs.cfg80211_send_vendor_event_to_upper_layer(&vap->wdev, NULL, 0, BGSCAN_COMPLETED_EVENT , GFP_KERNEL);
+	}	
+#endif /* DYNAMIC_ROAMING */
 #endif
 }
 	
Index: wlan/net80211/linux/osi_net80211/src/ieee80211_node.c
===================================================================
--- wlan/net80211/linux/osi_net80211/src/ieee80211_node.c	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/src/ieee80211_node.c	(working copy)
@@ -148,7 +148,6 @@
 ieee80211_fill_aironet_iapp_info(struct ieee80211vap *vap , struct ieee80211_node *selbs ,struct ieee80211_node * obss)
 {
 	uint8_t	aironet_iapp_oui[4] = {CCX_DDP_OUI_BYTES};
-
 	vap->aironet_iapp_pkt.aironet_iapp_id = IEEE80211_ELEMID_DDP;	
 	vap->aironet_iapp_pkt.aironet_iapp_len = (sizeof(struct ieee80211_iapp_pkt) - 2); //No need to include Length and IE
 	vap->aironet_iapp_pkt.aironet_old_channel = obss->ni_ic->ic_curchan->ic_ieee;  
@@ -1205,7 +1204,7 @@
 		ies->data = NULL;
 	}
 	if (ies->data == NULL) {
-		ies->data = (uint8_t *) kmalloc(len, GFP_ATOMIC);
+		ies->data = (uint8_t *) kzalloc(len, GFP_ATOMIC);
 		if (ies->data == NULL) {
 			ies->len = 0;
 			/* NB: pointers have already been zero'd above */
Index: wlan/net80211/linux/osi_net80211/src/ieee80211_sta.c
===================================================================
--- wlan/net80211/linux/osi_net80211/src/ieee80211_sta.c	(revision 57710)
+++ wlan/net80211/linux/osi_net80211/src/ieee80211_sta.c	(working copy)
@@ -421,6 +421,9 @@
 			 * manual roaming mode in which case an application
 			 * must issue an explicit scan request.
 			 */
+
+			ieee80211_notify_node_leave(ni); 
+
 			if (arg != 0) {
 				ieee80211_scan_assoc_fail(vap,
 					vap->iv_bss->ni_macaddr, arg);
@@ -1700,10 +1703,15 @@
 	struct ieee80211_key *key;
 	int hdrspace = 0;
 #endif
-#ifdef ONEBOX_CONFIG_CFG80211
-    uint8_t prv_rssi = 0;
-#endif
 
+#if (defined ONEBOX_CONFIG_CFG80211 && ((!defined DYNAMIC_ROAMING) && (!defined RSI_CCX)))
+	uint8_t prv_rssi = 0;
+#endif /* ONEBOX_CONFIG_CFG80211 */
+
+#ifdef RSI_CCX
+	uint8_t *reassoc_resp_cckm_ie = NULL ,*wpa_ie = NULL;
+#endif /* RSI_CCX */
+
 	wh = mtod(m0, struct ieee80211_frame *);
 	frm = (uint8_t *)&wh[1];
 	efrm = mtod(m0, uint8_t *) + m0->m_len;
@@ -1790,11 +1798,22 @@
 		if(IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_bssid))
         {
 #ifdef ONEBOX_CONFIG_CFG80211
+#if ( defined RSI_CCX || defined DYNAMIC_ROAMING)
+
+	/* In CCX CCKM-Fast roaming bgscan/roaming is not triggered based on CQM,
+	 * It will trigger upon receving bgscan_completed event from firmware and this is informed to 
+	 * supplicant using vendor event.
+	 */
+
+	/* To use DYNAMIC_ROAMING "BGSCAN_COMPLETED_EVENT" vendor event should be available in wpa_supplicant.
+	 * CCX CCKM-Fast roaming will uses DYNAMIC_ROAMING.
+	 * */
+#else
             //if( (ni->hal_priv_node.chno	!= ic->ic_curchan->ic_ieee) && !(scan.status & IEEE80211_BPARSE_OFFCHAN))	
             if (vap->hal_priv_vap->bgscan_params_ioctl.bg_ioctl && (!vap->hal_priv_vap->conn_in_prog)
                     && (vap->iv_state == IEEE80211_S_RUN) 
-                    && (vap->iv_flags & IEEE80211_F_WPA ? vap->hal_priv_vap->eapol4_confrm : true)) {
-                prv_rssi = vap->hal_priv_vap->rssi;
+		    && (vap->iv_flags & IEEE80211_F_WPA ? vap->hal_priv_vap->eapol4_confrm : true)) {
+		    prv_rssi = vap->hal_priv_vap->rssi;
                 if ((rssi > vap->hal_priv_vap->bgscan_params_ioctl.bgscan_threshold)) {
                     if(((rssi > prv_rssi) && ((rssi - vap->rssi_hyst) >= prv_rssi))
                             /* rssi_hyst is RSSI hysteresis in dBm. This value specifies
@@ -1821,7 +1840,8 @@
                     }
                 }
             }
-#endif
+#endif /* RSI_CCX DYNAMIC_ROAMING */
+#endif /* ONEBOX_CONFIG_CFG80211 */
             vap->hal_priv_vap->rssi = rssi;
         }
 
@@ -2230,12 +2250,24 @@
 						if (htinfo == NULL)
 							htinfo = frm;
 					}
+#ifndef RSI_CCX
 				}
+#else
+			} else if (iswpaoui(frm)) {
+				wpa_ie = frm;	
+			}
+#endif /* RSI_CCX */
 				/* XXX Atheros OUI support */
 				break;
 #ifdef RSI_CCX
 			case IEEE80211_ELEMID_CCKM:
+		IEEE80211_DBG_PRINT(vap, IEEE80211_MSG_ASSOC, 
+				("In %s Line %d CCKM REASSOC IE \n", __func__, __LINE__));
+#ifdef ONEBOX_CONFIG_CFG80211
+					reassoc_resp_cckm_ie  = frm;
+#else
 				ieee80211_notify_cckm_reassoc_resp(ni, &frm[6], (frm[1]-2));
+#endif
 			break;
 #endif
 #ifdef CONFIG_11W
@@ -2378,7 +2410,7 @@
 		    IEEE80211_ATH_CAP(vap, ni, IEEE80211_NODE_TURBOP) ?
 			", turbo" : ""
 		);
-#if defined(CONFIG_11R ) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)))
+#if ((defined (CONFIG_11R) || defined (RSI_CCX) ) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))))
 		if (ieee80211_ies_init(&ni->ni_ies, sfrm, efrm - sfrm)) {
 			if(rsn != NULL){
 				ni->ni_ies.rsn_ie = rsn;
@@ -2389,6 +2421,15 @@
 			if (ftie != NULL){
 				ni->ni_ies.ft_ie = ftie;
 			}
+
+#ifdef RSI_CCX
+			if(wpa_ie != NULL){
+				ni->ni_ies.wpa_ie = wpa_ie;
+			}
+			if (reassoc_resp_cckm_ie != NULL){
+				ni->ni_ies.reassoc_resp_cckm_ie = reassoc_resp_cckm_ie;
+			}
+#endif /* RSI_CCX */
 		}
 #endif //CONFIG_11R
 		ieee80211_new_state(vap, IEEE80211_S_RUN, subtype);
Index: wlan/supplicant/linux/wpa_supplicant/Makefile
===================================================================
--- wlan/supplicant/linux/wpa_supplicant/Makefile	(revision 57710)
+++ wlan/supplicant/linux/wpa_supplicant/Makefile	(working copy)
@@ -46,7 +46,8 @@
 
 #CFLAGS += -DBEST_RSSI_SELECTION
 CFLAGS += -DRSI_CHANGES
-#CFLAGS += -DRSI_CCX
+CFLAGS += -DRSI_CCX
+CFLAGS += -D DYNAMIC_ROAMING
 
 
 all: verify_config $(ALL) dynamic_eap_methods
Index: wlan/wlan_hal/osd_wlan/linux/onebox_wlan_ioctl.c
===================================================================
--- wlan/wlan_hal/osd_wlan/linux/onebox_wlan_ioctl.c	(revision 57710)
+++ wlan/wlan_hal/osd_wlan/linux/onebox_wlan_ioctl.c	(working copy)
@@ -1263,8 +1263,7 @@
         case  WLAN_I_Q_STATS:
             {
                 if (w_adapter->device_model == RSI_DEV_9116) {
-                    switch((unsigned char)wrq->u.data.flags)
-                        ONEBOX_DEBUG(ONEBOX_ZONE_ERROR,("WLAN IQ \n"));
+
                     if(copy_from_user(&w_adapter->wlan_iqs_stats, wrq->u.data.pointer,wrq->u.data.length))  //sizeof(wlan_iq_struct_t) in ioctl and driver are differ by 2 bytes
                     {
                         ONEBOX_DEBUG(ONEBOX_ZONE_ERROR, (TEXT("In %s Line %d:Copying Failed\n"), __func__, __LINE__));
